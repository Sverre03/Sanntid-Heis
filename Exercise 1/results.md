3: 
We start by creating two threads. Since we let both of them modify the shared variable 'i', without anything preventing the second thread from modifying/accessing it while the first thread is performing an operation on it, we have no way to determine the order of operations and the result becomes non-deterministic. Each instruction goes like this: Read - Modify - Write. So if thread 1 first reads the value of i and increments it, and at the same time thread 2 reads the value before thread 1 writes the incremented value to the address, we get that i is incremented by thread 1, but since thread 2 has read the value before it was incremented, the result is that incrementation that thread 1 performs is overwritten by the decrementation of the previous value of i by thread 2.

4:
Using 'phtread_mutex_t' is correct, as we want to prevent data in one thread from being accessed by the other thread simultaneously. This enables that one thread can lock the variable while it is reading, incrementing and writing it, before unlocking it again. The other thread can then lock the variable and read, decrement and write to it, with each thread continuosly taking turns. With a semaphore, both threads could unlock the variable, even though they weren't the ones to lock it in the first place.